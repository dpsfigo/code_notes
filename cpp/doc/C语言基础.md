## C语言特点

### 优点

1. 代码量小

2. 执行速度快

3. 功能强大

4. 编程自由

 

### 缺点

1. 写代码实现周期长

2. 可移植性较差

3. 过于自由，经验不足易出错

4. 对平台库依赖较多



## C语言的简洁性

### C语言32个关键字

| auto     | 声明自动变量                                                 |
| -------- | ------------------------------------------------------------ |
| break    | 跳出当前循环                                                 |
| case     | 开关语句分支                                                 |
| char     | 声明字符型变量或函数返回值类型                               |
| const    | 定义常量，如果一个变量被 const 修饰，那么它的值就不能再被改变 |
| continue | 结束当前循环，开始下一轮循环                                 |
| default  | 开关语句中的"其它"分支                                       |
| do       | 循环语句的循环体                                             |
| double   | 声明双精度浮点型变量或函数返回值类型                         |
| else     | 条件语句否定分支（与 if 连用）                               |
| enum     | 声明枚举类型                                                 |
| extern   | 声明变量或函数是在其它文件或本文件的其他位置定义             |
| float    | 声明浮点型变量或函数返回值类型                               |
| for      | 一种循环语句                                                 |
| goto     | 无条件跳转语句                                               |
| if       | 条件语句                                                     |
| int      | 声明整型变量或函数                                           |
| long     | 声明长整型变量或函数返回值类型                               |
| register | 声明寄存器变量                                               |
| return   | 子程序返回语句（可以带参数，也可不带参数）                   |
| short    | 声明短整型变量或函数                                         |
| signed   | 声明有符号类型变量或函数                                     |
| sizeof   | 计算数据类型或变量长度（即所占字节数）                       |
| static   | 声明静态变量                                                 |
| struct   | 声明结构体类型                                               |
| switch   | 用于开关语句                                                 |
| typedef  | 用以给数据类型取别名                                         |
| unsigned | 声明无符号类型变量或函数                                     |
| union    | 声明共用体类型                                               |
| void     | 声明函数无返回值或无参数，声明无类型指针                     |
| volatile | 说明变量在程序执行中可被隐含地改变                           |
| while    | 循环语句的循环条件                                           |

### C99 新增关键字

| `_Bool` | `_Complex` | `_Imaginary` | `inline` | `restrict` |
| ------- | ---------- | ------------ | -------- | ---------- |
|         |            |              |          |            |

### C11 新增关键字

| `_Alignas`       | `_Alignof`      | `_Atomic` | `_Generic` | `_Noreturn` |
| ---------------- | --------------- | --------- | ---------- | ----------- |
| `_Static_assert` | `_Thread_local` |           |            |             |

 ### 9种控制语句

![2016-05-31_173306](C语言基础.assets/clip_image002.png)

 ### 34种运算符

![2016-05-31_173424](C语言基础.assets/clip_image003.png)



## 数据类型

在 C 语言中，数据类型指的是用于声明不同类型的变量或函数的一个广泛的系统。变量的类型决定了变量存储占用的空间，以及如何解释存储的位模式。

C 中的类型可分为以下几种：

| 序号 | 类型与描述                                                   |
| :--- | :----------------------------------------------------------- |
| 1    | **基本类型：** 它们是算术类型，包括两种类型：整数类型和浮点类型。 |
| 2    | **枚举类型：** 它们也是算术类型，被用来定义在程序中只能赋予其一定的离散整数值的变量。 |
| 3    | **void 类型：** 类型说明符 *void* 表明没有可用的值。         |
| 4    | **派生类型：** 它们包括：指针类型、数组类型、结构类型、共用体类型和函数类型。 |



## 整数类型

下表列出了关于标准整数类型的存储大小和值范围的细节：

| 类型           | 存储大小    | 值范围                                               |
| :------------- | :---------- | :--------------------------------------------------- |
| char           | 1 字节      | -128 到 127 或 0 到 255                              |
| unsigned char  | 1 字节      | 0 到 255                                             |
| signed char    | 1 字节      | -128 到 127                                          |
| int            | 2 或 4 字节 | -32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647 |
| unsigned int   | 2 或 4 字节 | 0 到 65,535 或 0 到 4,294,967,295                    |
| short          | 2 字节      | -32,768 到 32,767                                    |
| unsigned short | 2 字节      | 0 到 65,535                                          |
| long           | 4 字节      | -2,147,483,648 到 2,147,483,647                      |
| unsigned long  | 4 字节      | 0 到 4,294,967,295                                   |

> 注意，各种类型的存储大小与系统位数有关，但目前通用的以64位系统为主。
>
> 以下列出了32位系统与64位系统的存储大小的差别（windows 相同）：
>
> ![img](C语言基础.assets/32-64.jpg)

为了得到某个类型或某个变量在特定平台上的准确大小，您可以使用 **sizeof** 运算符。表达式 *sizeof(type)* 得到对象或类型的存储字节大小。

## 浮点类型

下表列出了关于标准浮点类型的存储大小、值范围和精度的细节：

| 类型        | 存储大小 | 值范围                 | 精度      |
| :---------- | :------- | :--------------------- | :-------- |
| float       | 4 字节   | 1.2E-38 到 3.4E+38     | 6 位小数  |
| double      | 8 字节   | 2.3E-308 到 1.7E+308   | 15 位小数 |
| long double | 16 字节  | 3.4E-4932 到 1.1E+4932 | 19 位小数 |

不以f结尾的常量是double类型，以f结尾的常量(如3.14f)是float类型。



## 字符型

字符型变量用于存储一个单一字符，在 C 语言中用 char 表示，其中每个字符变量都会占用 1 个字节。在给字符型变量赋值时，需要用一对英文半角格式的单引号(' ')把字符括起来。

字符变量实际上并不是把该字符本身放到变量的内存单元中去，而是将该字符对应的 ASCII 编码放到变量的存储单元中。char的本质就是一个1字节大小的整型。

### 转义字符

| **转义字符** | **含义**                            | **ASCII****码值（十进制）** |
| ------------ | ----------------------------------- | --------------------------- |
| \a           | 警报                                | 007                         |
| \b           | 退格(BS) ，将当前位置移到前一列     | 008                         |
| \f           | 换页(FF)，将当前位置移到下页开头    | 012                         |
| \n           | 换行(LF) ，将当前位置移到下一行开头 | 010                         |
| \r           | 回车(CR) ，将当前位置移到本行开头   | 013                         |
| \t           | 水平制表(HT)  （跳到下一个TAB位置） | 009                         |
| \v           | 垂直制表(VT)                        | 011                         |
| \\           | 代表一个反斜线字符"\"               | 092                         |
| \'           | 代表一个单引号（撇号）字符          | 039                         |
| \"           | 代表一个双引号字符                  | 034                         |
| \?           | 代表一个问号                        | 063                         |
| \0           | 数字0                               | 000                         |
| \ddd         | 8进制转义字符，d范围0~7             | 3位8进制                    |
| \xhh         | 16进制转义字符，h范围0~9，a~f，A~F  | 3位16进制                   |

### 类型限定符

| **限定符** | **含义**                                                     |
| ---------- | ------------------------------------------------------------ |
| extern     | 声明一个变量，extern声明的变量没有建立存储空间。  extern int a; |
| const      | 定义一个常量，常量的值不能修改。  const int a = 10;          |
| volatile   | 防止编译器优化代码                                           |
| register   | 定义寄存器变量，提高效率。register是建议型的指令，而不是命令型的指令，如果CPU有空闲寄存器，那么register就生效，如果没有空闲寄存器，那么register无效。 |

## void 类型

void 类型指定没有可用的值。它通常用于以下三种情况下：

| 序号 | 类型与描述                                                   |
| :--- | :----------------------------------------------------------- |
| 1    | **函数返回为空** C 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 **void exit (int status);** |
| 2    | **函数参数为空** C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 **int rand(void);** |
| 3    | **指针指向 void** 类型为 void * 的指针代表对象的地址，而不是类型。例如，内存分配函数 **void \*malloc( size_t size );** 返回指向 void 的指针，可以转换为任何数据类型。 |



## 数值溢出

当超过一个数据类型能够存放最大的范围时，数值会溢出。

有符号位最高位溢出的区别：符号位溢出会导致数的正负发生改变，但最高位的溢出会导致最高位丢失。



## 头文件

### \#include< > 与 #include " "的区别：

<  > 表示系统直接按系统指定的目录检索

" " 表示系统先在 "" 指定的路径(没写路径代表当前路径)查找头文件，如果找不到，再按系统指定的目录检索



### extern

如果需要在一个源文件中引用另外一个源文件中定义的变量，我们只需在引用的文件中将变量加上 extern 关键字的声明即可。

## 左值（Lvalues）和右值（Rvalues）

C 中有两种类型的表达式：

1. **左值（lvalue）：**指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。
2. **右值（rvalue）：**术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。

变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。下面是一个有效的语句：

```
int g = 20;
```



## C程序编译步骤

C代码编译成可执行程序经过4步：

1）预处理：宏定义展开、头文件展开、条件编译等，同时将代码中的注释删除，这里并不会检查语法

2）编译：检查语法，将预处理后文件编译生成汇编文件

3）汇编：将汇编文件生成目标文件(二进制文件)

4）链接：C语言写的程序是需要依赖各种库的，所以编译之后还需要把库链接到最终的可执行程序中去

<img src="C语言基础.assets/image-20210218210854601.png" alt="image-20210218210854601" style="zoom:50%;" />

## 寄存器、缓存、内存三者关系

按与CPU远近来分，离得最近的是寄存器，然后缓存(CPU缓存)，最后内存。

CPU计算时，先预先把要用的数据从硬盘读到内存，然后再把即将要用的数据读到寄存器。于是 CPU<--->寄存器<--->内存，这就是它们之间的信息交换。

那为什么有缓存呢？因为如果老是操作内存中的同一址地的数据，就会影响速度。于是就在寄存器与内存之间设置一个缓存。

因为从缓存提取的速度远高于内存。当然缓存的价格肯定远远高于内存，不然的话，机器里就没有内存的存在。

由此可以看出，从远近来看：CPU〈---〉寄存器〈---> 缓存 <---> 内存。



## 二进制

二进制是计算技术中广泛采用的一种数制。二进制数据是用0和1两个数码来表示的数。它的基数为2，进位规则是“逢二进一”，借位规则是“借一当二”。

当前的计算机系统使用的基本上是二进制系统，数据在计算机中主要是以补码的形式存储的。 

| **术语**     | **含义**                                                     |
| ------------ | ------------------------------------------------------------ |
| bit(比特)    | 一个二进制代表一位，一个位只能表示0或1两种状态。数据传输是习惯以“位”（bit）为单位。 |
| Byte(字节)   | 一个字节为8个二进制，称为8位，计算机中存储的最小单位是字节。数据存储是习惯以“字节”（Byte）为单位。 |
| WORD(双字节) | 2个字节，16位                                                |
| DWORD        | 两个WORD，4个字节，32位                                      |
| 1b           | 1bit，1位                                                    |
| 1B           | 1Byte,1字节，8位                                             |
| 1k，1K       | 1024                                                         |
| 1M(1兆)      | 1024k, 1024*1024                                             |
| 1G           | 1024M                                                        |
| 1T           | 1024G                                                        |
| 1Kb(千位)    | 1024bit,1024位                                               |
| 1KB(千字节)  | 1024Byte，1024字节                                           |
| 1Mb(兆位)    | 1024Kb = 1024 * 1024bit                                      |
| 1MB(兆字节)  | 1024KB = 1024 * 1024Byte                                     |

## 计算机内存数值存储方式

### 原码

一个数的原码(原始的二进制码)有如下特点：

- 最高位做为符号位，0表示正,为1表示负

- 其它数值部分就是数值本身绝对值的二进制数

- 负数的原码是在其绝对值的基础上，最高位变为1

- 下面数值以1字节的大小描述：

  | **十进制数** | **原码**  |
  | ------------ | --------- |
  | +15          | 0000 1111 |
  | -15          | 1000 1111 |
  | +0           | 0000 0000 |
  | -0           | 1000 0000 |

   

原码表示法简单易懂，与带符号数本身转换方便，只要符号还原即可，但当两个正数相减或不同符号数相加时，必须比较两个数哪个绝对值大，才能决定谁减谁，才能确定结果是正还是负，所以原码不便于加减运算。

### 反码

- 对于正数，反码与原码相同

- 对于负数，符号位不变，其它部分取反(1变0,0变1)

| **十进制数** | **反码**  |
| ------------ | --------- |
| +15          | 0000 1111 |
| -15          | 1111 0000 |
| +0           | 0000 0000 |
| -0           | 1111 1111 |

反码运算也不方便，通常用来作为求补码的中间过渡。

### 补码

**在计算机系统中，数值一律用补码来存储。**

 补码特点：

- 对于正数，原码、反码、补码相同

- 对于负数，其补码为它的反码加1

- 补码符号位不动，其他位求反，最后整个数加1，得到原码

| **十进制数** | **补码**  |
| ------------ | --------- |
| +15          | 0000 1111 |
| -15          | 1111 0001 |
| +0           | 0000 0000 |
| -0           | 0000 0000 |

**在计算机系统中，数值一律用补码来存储**，主要原因是：

- 统一了零的编码

- 将符号位和其它位统一处理

- 将减法运算转变为加法运算

- 两个用补码表示的数相加时，如果最高位(符号位)有进位，则进位被舍弃

## sizeof关键字

 

- sizeof不是函数，所以不需要包含任何头文件，它的功能是计算一个数据类型的大小，单位为字节

- sizeof的返回值为size_t

- size_t类型在32位操作系统下是unsigned int，是一个无符号的整数

## 运算符优先级

| **优先级** | **运算符**         | **名称或含义**   | **使用形式**                | **结合方向** | **说明**   |
| ---------- | ------------------ | ---------------- | --------------------------- | ------------ | ---------- |
| **1**      | **[]**             | 数组下标         | 数组名[常量表达式]          | 左到右       | --         |
|            | **()**             | 圆括号           | (表达式）/函数名(形参表)    | --           |            |
|            | **.**              | 成员选择（对象） | 对象.成员名                 | --           |            |
|            | **->**             | 成员选择（指针） | 对象指针->成员名            | --           |            |
|            |                    |                  |                             |              |            |
| **2**      | **-**              | 负号运算符       | -表达式                     | **右到左**   | 单目运算符 |
|            | **~**              | 按位取反运算符   | ~表达式                     |              |            |
|            | **++**             | 自增运算符       | ++变量名/变量名++           |              |            |
|            | **--**             | 自减运算符       | --变量名/变量名--           |              |            |
|            | *****              | 取值运算符       | *指针变量                   |              |            |
|            | **&**              | 取地址运算符     | &变量名                     |              |            |
|            | **!**              | 逻辑非运算符     | !表达式                     |              |            |
|            | **(****类型****)** | 强制类型转换     | (数据类型)表达式            | --           |            |
|            | **sizeof**         | 长度运算符       | sizeof(表达式)              | --           |            |
|            |                    |                  |                             |              |            |
| **3**      | **/**              | 除               | 表达式/表达式               | 左到右       | 双目运算符 |
|            | *****              | 乘               | 表达式*表达式               |              |            |
|            | **%**              | 余数（取模）     | 整型表达式%整型表达式       |              |            |
| **4**      | **+**              | 加               | 表达式+表达式               | 左到右       | 双目运算符 |
|            | **-**              | 减               | 表达式-表达式               |              |            |
| **5**      | **<<**             | 左移             | 变量<<表达式                | 左到右       | 双目运算符 |
|            | **>>**             | 右移             | 变量>>表达式                |              |            |
|            |                    |                  |                             |              |            |
| **6**      | **>**              | 大于             | 表达式>表达式               | 左到右       | 双目运算符 |
|            | **>=**             | 大于等于         | 表达式>=表达式              |              |            |
|            | **<**              | 小于             | 表达式<表达式               |              |            |
|            | **<=**             | 小于等于         | 表达式<=表达式              |              |            |
| **7**      | **==**             | 等于             | 表达式==表达式              | 左到右       | 双目运算符 |
|            | **！****=**        | 不等于           | 表达式!=  表达式            |              |            |
|            |                    |                  |                             |              |            |
| **8**      | **&**              | 按位与           | 表达式&表达式               | 左到右       | 双目运算符 |
| **9**      | **^**              | 按位异或         | 表达式^表达式               | 左到右       | 双目运算符 |
| **10**     | **\|**             | 按位或           | 表达式\|表达式              | 左到右       | 双目运算符 |
| **11**     | **&&**             | 逻辑与           | 表达式&&表达式              | 左到右       | 双目运算符 |
| **12**     | **\|\|**           | 逻辑或           | 表达式\|\|表达式            | 左到右       | 双目运算符 |
|            |                    |                  |                             |              |            |
| **13**     | **?:**             | 条件运算符       | 表达式1?  表达式2:  表达式3 | **右到左**   | 三目运算符 |
|            |                    |                  |                             |              |            |
| **14**     | **=**              | 赋值运算符       | 变量=表达式                 | **右到左**   | --         |
|            | **/=**             | 除后赋值         | 变量/=表达式                | --           |            |
|            | ***=**             | 乘后赋值         | 变量*=表达式                | --           |            |
|            | **%=**             | 取模后赋值       | 变量%=表达式                | --           |            |
|            | **+=**             | 加后赋值         | 变量+=表达式                | --           |            |
|            | **-=**             | 减后赋值         | 变量-=表达式                | --           |            |
|            | **<<=**            | 左移后赋值       | 变量<<=表达式               | --           |            |
|            | **>>=**            | 右移后赋值       | 变量>>=表达式               | --           |            |
|            | **&=**             | 按位与后赋值     | 变量&=表达式                | --           |            |
|            | **^=**             | 按位异或后赋值   | 变量^=表达式                | --           |            |
|            | **\|=**            | 按位或后赋值     | 变量\|=表达式               | --           |            |
|            |                    |                  |                             |              |            |
| **15**     | **，**             | 逗号运算符       | 表达式,表达式,…             | 左到右       | --         |

## 跳转语句break、continue、goto

### break语句

在switch条件语句和循环语句中都可以使用break语句：

- 当它出现在switch条件语句中时，作用是终止某个case并跳出switch结构。

- 当它出现在循环语句中，作用是跳出当前内循环语句，执行后面的代码。

- 当它出现在嵌套循环语句中，跳出最近的内循环语句，执行后面的代码。

### continue语句

在循环语句中，如果希望立即终止本次循环，并执行下一次循环，此时就需要使用continue语句。

### goto语句(无条件跳转，尽量少用)



## 一维数组

### 一维数组的定义和使用

- 数组名字符合标识符的书写规定(数字、英文字母、下划线)

- 数组名不能与其它变量名相同，同一作用域内是唯一的

- 方括号[]中常量表达式表示数组元素的个数

  ```
  int a[3]表示数组a有3个元素
  
  其下标从0开始计算，因此3个元素分别为a[0],a[1],a[2]
  ```

- 定义数组时[]内最好是常量，使用数组时[]内即可是常量，也可以是变量

### 一维数组的初始化

在定义数组的同时进行赋值，称为初始化。全局数组若不初始化，编译器将其初始化为零。局部数组若不初始化，内容为随机值。

### 数组名

数组名是一个地址的常量，代表数组中首元素的地址。

## 二维数组

- 在内存中并并存在二维数组，二维数组实际的硬件存储器是连续编址的，也就是说内存中只有一维数组，即放完一行之后顺次放入第二行，和一维数组存放方式是一样的。



## 字符数组与字符串

### 字符数组与字符串区别

- C语言中没有字符串这种数据类型，可以通过char的数组来替代；
- 字符串一定是一个char的数组，但char的数组未必是字符串；

- 数字0(和字符‘\0’等价)结尾的char数组就是一个字符串，但如果char数组没有以数字0结尾，那么就不是一个字符串，只是普通字符数组，所以字符串是一种特殊的char的数组。

  ```c++
  #include <stdio.h>
  
  int main()
  {
  	char c1[] = { 'c', ' ', 'p', 'r', 'o', 'g' }; //普通字符数组
  	printf("c1 = %s\n", c1); //乱码，因为没有’\0’结束符
  
  	//以‘\0’(‘\0’就是数字0)结尾的字符数组是字符串
  	char c2[] = { 'c', ' ', 'p', 'r', 'o', 'g', '\0'}; 
  	printf("c2 = %s\n", c2);
  
  	//字符串处理以‘\0’(数字0)作为结束符，后面的'h', 'l', 'l', 'e', 'o'不会输出
  	char c3[] = { 'c', ' ', 'p', 'r', 'o', 'g', '\0', 'h', 'l', 'l', 'e', 'o', '\0'};
  	printf("c3 = %s\n", c3);
  
  	return 0;
  }
  
  ```

  

## 函数

### 形参列表

在定义函数时指定的形参，在未出现函数调用时，它们并不占内存中的存储单元，因此称它们是形式参数或虚拟参数，简称形参，表示它们并不是实际存在的数据，所以，形参里的变量不能赋值。

在定义函数时指定的形参，必须是，类型+变量的形式

在定义函数时指定的形参，可有可无，根据函数的需要来设计，如果没有形参，圆括号内容为空，或写一个void关键字：

### 返回值

如果函数返回的类型和return语句中表达式的值不一致，则以函数返回类型为准，即函数返回类型决定返回值的类型。对数值型数据，可以自动进行类型转换。

### 函数的形参和实参

- 形参出现在函数定义中，在整个函数体内都可以使用，离开该函数则不能使用。
- 实参出现在主调函数中，进入被调函数后，实参也不能使用。
- 实参变量对形参变量的数据传递是“值传递”，即单向传递，只由实参传给形参，而不能由形参传回来给实参。
- 在调用函数时，编译系统临时给形参分配存储单元。调用结束后，形参单元被释放。
- 实参单元与形参单元是不同的单元。调用结束后，形参单元被释放，函数调用结束返回主调函数后则不能再使用该形参变量。实参单元仍保留并维持原值。因此，在执行一个被调用函数时，形参的值如果发生改变，并不会改变主调函数中实参的值。

### 函数的声明

注意：一个函数只能被定义一次，但可以声明多次。

### 函数定义和声明的区别

1）定义是指对函数功能的确立，包括指定函数名、函数类型、形参及其类型、函数体等，它是一个完整的、独立的函数单位。

2）声明的作用则是把函数的名字、函数类型以及形参的个数、类型和顺序(注意，不包括函数体)通知编译系统，以便在对包含函数调用的语句进行编译时，据此对其进行对照检查（例如函数名是否正确，实参与形参的类型和个数是否一致）。

为了避免同一个文件被include多次，C/C++中有两种方式，一种是 #ifndef 方式，一种是 #pragma once 方式。